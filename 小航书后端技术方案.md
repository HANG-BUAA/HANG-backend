# 小航书后端技术方案

本文档为小航书项目第一期后端技术报告，介绍了整个后端服务架构，技术选型，实现思路以及部分重点问题的处理方案。

## 系统架构

本系统后端采用**微服务架构**，主要由以下11个服务构成：

1. 主后端服务`HANG-backend`: 对客户端提供**API**，并向下串联起各服务；
2. 搜索微服务`HANG-search-client`: 负责系统中搜索任务，向上与主服务之间通过`rabbitmq`异步地同步数据，并提供相应查询接口；向下与`elasticsearch`交互，执行**全文本搜索功能**；
3. 日志微服务`HANG-log-processor`: 负责系统**日志记录**，同样通过`rabbitmq`接受各服务的日志记录，并对主后端服务提供查询接口；向下与`mongodb`数据库交互，记录日志信息；
4. 爬虫微服务`HANG-scraper-service`: 负责定时抓取互联网数据，并存储至`mongodb`中，对外提供日志查询相应接口；
5. 数据库服务`mysql`: 用作系统的**主关系数据库**，记录主后端服务相应的记录；
6. 数据库服务`redis`: 用于存储系统中**临时数据**，以及**数据缓存**；
7. 数据库服务`mongodb`: 用于存储系统中**非结构化以及时限数据**，并执行**聚合查询**功能；
8. 消息队列服务`rabbitmq`: 用于系统中**异步化同步操作**，以及对**分布式架构负载均衡**的开放考虑；
9. 搜索引擎服务`elasticsearch`: 用于存储系统检索的数据信息，执行**全文本搜索**；
10. AIGC模型部署服务`ComfyUI`: 用于部署`flux`模型，支持系统中**文生图**相关功能；
11. 模型调度服务`ComfyUI-server`: 用于**工厂化部署**ComfyUI工作流，**调度上下层服务**，并执行**web hook**.

各服务之间的关系如下图所示：

TODO

## 技术选型

| 技术选型      | 官方文档/链接                                                | 用途                                                         |                           选型考量                           |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | :----------------------------------------------------------: |
| golang语言    | [https://go.dev/](https://go.dev/)                           | 主后端语言                                                   | go语言在主流后端语言中**效率当属最高**，纯编译设计以及协程的特性使得其运行效率远高于JAVA，python等语言实现的后端框架。 |
| gin框架       | [https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin) | 主后端框架                                                   | gin框架是go语言实现的应用级框架中**效率最高**，对并发支持的最好的框架，据官方评测单机最高可承受3.1W qps并发，且架构优良，功能完善，**对开发者非常友好**。 |
| gorm框架      | [https://gorm.io/zh_CN/docs/index.html](https://gorm.io/zh_CN/docs/index.html) | 主后端的ORM框架                                              | go语言中最完善的ORM框架，提供，包装了丰富的sql相关接口，**增加开发效率**。 |
| rabbitmq      | [https://www.rabbitmq.com/](https://www.rabbitmq.com/)       | 用于系统异步消息队列，同步各服务间信息。生产者为主后端，消费者为搜索微服务与日志微服务 | 全世界中最广泛使用的消息队列，**提供了多语言sdk**（系统中用到了go语言的amtp以及python的异步版本aio_pika）。相比kafka，socketmq等同类消息队列，rabbitmq更**轻量**，但**功能完善**，我们系统中主要使用了direct路由机制。该设计使得后面扩展为分布式架构时重构成本大大减小。 |
| mysql         | [https://www.mysql.com/cn/](https://www.mysql.com/cn/)       | 用作系统主关系数据库                                         | 世界上最流行的开源关系数据库之一，文档齐全，**各语言及框架支持完备**，性能也不错。 |
| redis         | [https://redis.io/](https://redis.io/)                       | 用于存储验证码等临时信息，以及数据缓存                       | 对于**验证码**这一类的数据而言，入库非常不合适，因为5min过期后就再也没用了，故而存储在内存里非常合适；同时系统中近期的帖子等信息会被频繁地访问，将部分**数据缓存**到内存中会大大减小系统查询开销；同时，目前系统中部分的锁机制实现方式是应用程序级别的锁，之后迁移到分布式架构时可能会使用redis实现**分布式锁** |
| mongodb       | [https://www.mongodb.com/zh-cn](https://www.mongodb.com/zh-cn) | 用于存储日志，爬虫所得数据等非结构化的，有存储时限的数据，并执行相应的聚合查询 | 系统中不同类比的日志信息，以及爬虫所得信息**嵌套层次太深**，常规的关系数据库受到第一范式的显示，处理起来相当吃力，mongo的**bson格式**存储使得系统系统可以轻松地处理这些信息；并且日志中部分类别，如访问日志等，一般设有**存储时限**，mongo的**ttl字段**的设定可以在系统层级处理这些，而无需应用程序的协调 |
| elasticsearch | [https://www.elastic.co/cn/elasticsearch](https://www.elastic.co/cn/elasticsearch) | 用作系统的分布式搜索引擎，执行全文本搜索功能                 | 系统需求分析时我们明确了树洞系统最核心的功能是对外提供精准的搜索能力，elastcearch作为上一代工业互联网的杰出产品，在稳定性以及效率上有着巨大的优势，能够轻松地执行**全文本搜索**的任务，并且其search_after功能的设定与系统**游标分页**功能兼容 |
| fastapi       | [https://fastapi.tiangolo.com/#interactive-api-docs-upgrade](https://fastapi.tiangolo.com/#interactive-api-docs-upgrade) | 用作搜索微服务以及日志微服务的http服务器                     | 由于其异步协程的特性，使得架构在一定程度上打破了python语言全局锁的限制，成为了python语言实现出的**性能最强**的后端框架，官方说法和go（编译，协程特性）语言以及node.js（JIT特性）的效率相当；且抽象层次非常高，**对开发者非常方便**，尤其适合用作微服务架构 |
| ComfyUI       | [https://github.com/comfyanonymous/ComfyUI](https://github.com/comfyanonymous/ComfyUI) | 用于部署flux模型相关工作流                                   | 当今世界AIGC领域**最流行的**Stable Diffusion系列模型的部署框架，其工作流设定以及内置的异步队列还有基础api端口还有节点式设计使得其非常**方便扩展** |

以上为系统中主要的技术选型，对于一些语言第三方sdk等不一一列举，可以参考系统源代码。

## 数据库表结构设计

略（数据库作业）

## 重点技术方案

### 1. 假名分配

由于本系统支持在一个帖子下匿名或实名发言，使得为用户在相应的帖子下发表评论时分配假名成为系统的关键功能，对于该功能，我在初期调研清华，北大等学校树洞论坛时发现大家的设定基本相同，如下：

1. 对于同一个帖子（post）而言，其下面的匿名发表评论的用户的假名之间不同，但统一用户发表多条评论时需使用同一假名；
2. 系统中假名的顺序是写死的，比如在同一帖子下，第一个匿名评论的用户叫Bob，第二个叫Alice...

我们认为该设定合理，不难抽象成如下的问题：

1. 对于相同的`post_id`，不同的`user_id`之间分配的假名应当不同；
2. 对于相同的`post_id`和`user_id`，应当只有用户第一次发表时才分配假名，后面再发言时使用相同的假名。

我参考了[清华大学第三代树洞的源码](https://github.com/treehollow/treehollow-backend)后，发现它们只是简单地在系统中为假名打表，然后用户发表评论时检测是否在同样的帖子下发表过评论，如果没有就分配一个假名。

但是这样的设计时存在bug的：在高并发的场景下，如果两个用户同时第一次地在某个帖子下发表评论，由于此处没有执行数据库的插入操作，导致